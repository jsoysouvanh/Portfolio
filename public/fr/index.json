{"categories":[],"pages":[],"posts":[{"link":"/fr/posts/kodgen-refureku/","text":"Détails Technologies / Langages : C++17, libclang, toml11\r, Visual Studio 2019, Git, Trello Plateforme : Windows / Linux Présentation A l\u0026rsquo;origine, Kodgen et Refureku étaient une seule librairie, mais je me suis rendu compte qu\u0026rsquo;une partie du code pouvait être réutilisée pour des besoins autres, c\u0026rsquo;est pourquoi j\u0026rsquo;ai décidé de séparer le code initial en 2 librairies distinctes.\nKodgen\rest une librairie qui permet de générer des fichiers à partir de données extraites de fichiers C++. Elle sert de base à Refureku en parsant et générant le code de réflexion pour chaque entité c++ taggée. La manière dont sont taggées les entités dans le code C++ est personnalisable en modifiant un fichier de configuration, ou en modifiant le main du parser/générateur directement.\nRefureku\rest une librairie de réflexion dynamique c17. Elle permet d\u0026rsquo;accéder aux informations d\u0026rsquo;entités C comme les classes ou les enums.\nMotivation J\u0026rsquo;ai écrit cette librairie d\u0026rsquo;abord car la réflexion est un sujet qui m\u0026rsquo;attire beaucoup en programmation. Mon expérience passée sur le Turbo Engine\rm\u0026rsquo;a donné envie de continuer à explorer et améliorer ce qu\u0026rsquo;on avait déjà pu mettre en place. La réflexion n\u0026rsquo;est à ce jour pas supportée nativement par le C++, et les premières ébauches n\u0026rsquo;arriveront pas avant C++23. La réflexion en C#, au contraire, est extrêmement poussée et agréable à utiliser. Je me suis donc inspiré de l\u0026rsquo;architecture C# pour développer Refureku.\nIl existe déjà un certain nombre de librairies de réflexion C++, mais la plupart ont des défauts que je voulais éviter dans mon implémentation. Par exemple, dans certaines implémentations il faut réécrire toutes les informations des entités réfléchies une seconde fois après la déclaration de l\u0026rsquo;entité en question. Cela peut ressembler à quelque chose comme :\nCPP\rRéduire\rCopy\rclass ExampleClass { private: int i; }; REFLECT_CLASS(\u0026#34;ExampleClass\u0026#34;, (int) i)\rCliquez pour développer et voir plus\rÉcrire les choses 2 fois est 1. fastidieux et 2. source d\u0026rsquo;erreur quand on modifie les entités. L\u0026rsquo;avantage de ce type d\u0026rsquo;implémentation cependant est que l\u0026rsquo;on a le contrôle sur ce qui est réfléchi et ce qui ne l\u0026rsquo;est pas. Il serait certes plus agréable encore que toute la base de code soit réfléchie automatiquement, mais cela aurait un impact non négligeable sur la mémoire utilisée (notamment à cause des includes de librairies externes ou de la STL). Il est donc intéressant de pouvoir choisir ce qui doit être réfléchi dans le programme. Un deuxième avantage de pouvoir sélectionner les entités est que l\u0026rsquo;on peut ajouter un système d\u0026rsquo;attributs pour chaque entité réfléchie. Cela peut être très utile pour développer l\u0026rsquo;éditeur d\u0026rsquo;un moteur de jeu.\nAvec Refureku, il suffit de tagger une entité avec une macro pour la réfléchir, et on peut fournir des attributs supplémentaires dans la macro pour ajouter des informations sur l\u0026rsquo;entité. De cette façon, on n\u0026rsquo;écrit l\u0026rsquo;entité qu\u0026rsquo;une seule fois, et il est facile de modifier le code par la suite sans générer d\u0026rsquo;erreur.\nCPP\rRéduire\rCopy\r#include \u0026#34;Generated/ExampleClass.rfk.h\u0026#34; class ReflectedClass(ExampleClassAttribute1) ExampleClass { private: ReflectedField(ExampleFieldAttribute1, ExampleFieldAttribute2) int i; ExampleClass_GENERATED };\rCliquez pour développer et voir plus\r","title":"Kodgen \u0026 Refureku"},{"link":"/fr/posts/lambos-tale/","text":"\rLambo's Tale by cfazilleau\rDétails Effectif : 4 programmeurs, 4 game designers, 3 artistes Délai : 5 semaines Technologies / Langages : Unity 2019.3, C#, Visual Studio 2019, Perforce, Trello Plateforme : PC / Manette Présentation Ce projet realisé en collaboration avec des programmeurs, designers et artistes est notre projet de fin de 3ème année. C\u0026rsquo;est un projet un petit peu particulier car il a entièrement été réalisé à distance à cause de la situation sanitaire liée au Covid-19.\nLambo\u0026rsquo;s Tale est un Metroidvania dans lequel on incarne Lambo, un petit mouton qui cherche à venger sa soeur du gang des loups.\nContribution personnelle Système de génération de level procédural Ennemis + IA Rédaction d\u0026rsquo;une partie du TDD (Technical Design Document) Caméra Character Une partie du controller (jump snap, ennemies snap) Système d\u0026rsquo;intéractions (shop, portes) Système d\u0026rsquo;inventaire semi-persistant Logique des arènes Système de feedbacks générique (particules, sons, vibrations, camera shakes) Mise en place d\u0026rsquo;un système de pooling Développement d\u0026rsquo;une partie des briques de level design (portes, clés, destructibles, spikes, vie, oeufs\u0026hellip;) Loading screen Système pour les feedbacks de dégâts Parties scriptées de la FTUE (First Time User Experience - Tutoriel) Logique du shop Intégration d\u0026rsquo;assets (animations, sprites) ","title":"Lambo's Tale"},{"link":"/fr/posts/poshon/","text":"Détails Effectif : 2 programmeurs Délai : 2 semaines Technologies / Langages : Unity 2019.3, C#, Visual Studio 2019, Git, Trello Plateforme : Nintendo Switch Présentation Ce projet était un projet de R\u0026amp;D sur la Nintendo Switch. Notre objectif était d\u0026rsquo;explorer les fonctionnalités proposées par la console en développant un party-game en multijoueur local. Poshon (ポーション) est donc un party-game en multijoueur local dans lequel l\u0026rsquo;objectif est de reproduire des potions le plus fidèlement possible dans un temps imparti. Pour faire changer les attributs d\u0026rsquo;une potion, il faut intéragir avec les machines du niveau et compléter des mini-jeux.\nContribution personnelle Création d\u0026rsquo;un framework style Game Mode / Game State / Character / Controller Gameflow Camera / Controller / Character Système d\u0026rsquo;objets avec lesquels on peut intéragir (il semblerait après recherche que le mot intéractible n\u0026rsquo;existe pas en français\u0026hellip; ni en anglais) Mise en place des mini-jeux pour chaque\u0026hellip; intéractible, en explorant les inputs proposés par la Switch (gyroscope, accéléromètre, différentes touches) Mise en place de la dimension multijoueur grâce au nouvel Input System de Unity Création des différents levels Loading screen Système de scoring ","title":"Poshon"},{"link":"/fr/posts/turbo-engine/","text":"Détails Effectif : 4 programmeurs Délai : 5 mois Technologies / Langages : Visual Studio 2017, Git, Trello, C++17, Python 3.7 Librairies : Qt, GLFW, PhysX, FMOD, nlohmann json, OpenGL, Freetype, stb_image, Glew, Autodesk FBX SDK, TinyObjLoader, SOL2, RuntimeCompiledCPlusPlus Présentation Ce projet de fin de deuxième année était constitué d\u0026rsquo;un ensemble de trois sous-projets :\nDéveloppement d\u0026rsquo;un moteur de jeu vidéo Développement d\u0026rsquo;un éditeur du moteur Développement d\u0026rsquo;un jeu à l\u0026rsquo;aide de l\u0026rsquo;éditeur Le Turbo Engine Le Turbo Engine est un moteur de jeu vidéo 3D pensé pour permettre un développement rapide et confortable à la manière des plus grands. Il implémente les fonctionnalités de base telles que la physique avec un système de layer flexible (PhysX 3.4), la gestion du son (FMOD), un éditeur de material, ou un rendu PBR agrémenté de quelques effets de post-process. Le système de réflection permet la sérialisation au format binaire (custom) ou texte (json via la librairie nlohmann json). Grâce au hotreload, on peut ajouter et/ou modifier des scripts C++ utilisables par la suite en tant que component dans les entités de la scène. Le système de scripting C++ se veut agréable, et il suffit à l\u0026rsquo;utilisateur de spécifier certaines propriétés au dessus de ses variables pour les appliquer. Un outil tiers développé en Python 3.7 analyse les fichiers de scripts, puis génère des fichiers de métadonnées exploités par le moteur.\nLe Turbo Editor Le Turbo Editor est un outil développé avec la librairie Qt. Il est composé d\u0026rsquo;un certain nombre de widgets qui sont détachables de la fenêtre principale, permettant à l\u0026rsquo;utilisateur de les réorganiser et de les déplacer sur plusieurs écrans. Les différents widgets sont les suivants :\nL\u0026rsquo;explorateur de fichiers pour avoir accès à tous les dossiers/fichiers du projet Le loggeur Le Scene tree, qui permet de visualiser les entités présentes dans la scène ainsi que leur hiérarchie L\u0026rsquo;inspecteur, qui affiche et permet d\u0026rsquo;intéragir avec les components d\u0026rsquo;une entité La Liste de sons, qui affiche une liste de tous les fichiers audio du projet et permet de les écouter Le Mixeur, qui permet de créer et de mixer différents canaux de sons L\u0026rsquo;éditeur de material, pour créer et modifier les matérials à partir des shaders et textures du projet Les paramètres de physique qui permettent de gérer et configurer différents layers de physique La game view Les scene view, qui peuvent être ouvertes en 4 exemplaires simultanément pour éditer/visualiser la scène de différents points de vue On peut créer des scripts avec des template personnalisables et les compiler d\u0026rsquo;un simple clic. Les scripts pourront par la suite être ajoutés aux entités de la scène, et les variables marquées comme \u0026ldquo;réfléchies\u0026rdquo; dans les scripts seront disponibles dans l\u0026rsquo;inspecteur.\nVoici un exemple de script (header) généré auquel on aurait ajouté quelques variables :\nCPP\rRéduire\rCopy\r#pragma once #include \u0026lt;TEConfig.hpp\u0026gt; #include \u0026lt;Core/FundamentalTypes.hpp\u0026gt; #include \u0026lt;Core/ECS/Components/BehaviorComponent.hpp\u0026gt; #include \u0026lt;GameplayMinIncludes.hpp\u0026gt; // * This include should always be the last one. moving it will cause conflicts #include \u0026#34;Generated/TestScript.generatedhpp\u0026#34; class [[ReflectedClass(Component)]] TestScript : public turbo::core::ecs::BehaviorComponent { TURBO_CLASS_GENERATION() private: #pragma region Variables [[ReflectedAttr]] TEint16\tm_testInt = 16u; [[ReflectedAttr]] Vector\u0026lt;math::Vector3f\u0026gt;\tm_vector; [[ReflectedAttr]] RigidBody*\tm_rigidBody; //This attribute will not be shown in the editor thanks to the HiddenInEditor attribute [[ReflectedAttr, HiddenInEditor]] TEfloat\tm_hiddenAttribute; #pragma endregion protected: #pragma region Methods virtual void init()\tnoexcept override; virtual void update()\tnoexcept override; #pragma endregion }; REGISTER_TO_REFLECTION()\rCliquez pour développer et voir plus\rEt le .cpp correspondant, lui aussi auto généré et sans modifications (excepté l\u0026rsquo;include de RigidBody) :\nCPP\rRéduire\rCopy\r#include \u0026#34;TestScript.hpp\u0026#34; #include \u0026#34;Components/Physic/RigidBody.hpp\u0026#34; void TestScript::init() noexcept { Parent0::init(); } void TestScript::update() noexcept { Parent0::update(); }\rCliquez pour développer et voir plus\rComme on peut le voir, de la même façon que Unreal Engine 4, on peut appeler dans les méthodes overridées la fonction base du ou des parents (via Parent0, Parent1, \u0026hellip; ParentN) pour étendre des comportements.\nLe Turbo Game Le jeu que nous avions à développer devait dans la mesure du possible servir de vitrine au moteur, pour en démontrer toutes les fonctionnalités. Certaines contraintes nous étaient aussi imposées, comme le fait que le jeu devait être un FPS-Puzzle. Nous avons donc opté pour un jeu d\u0026rsquo;aventure narratif parsemé d\u0026rsquo;énigmes. On incarne dans le jeu un archéologue qui s\u0026rsquo;aventure dans un temple ancien, guidé par la voix de sa coéquipière qui lui donne des informations par talkie walkie. Je n\u0026rsquo;en dirai pas plus ici pour garder quelques surprises pour les lecteurs voulant tester le jeu.\nContribution personnelle J\u0026rsquo;ai eu l\u0026rsquo;occasion lors de ce projet de travailler sur les 3 sous-projets que sont le moteur, l\u0026rsquo;éditeur et le jeu. En tant que chef de projet, j\u0026rsquo;ai pu être confronté à de nombreuses problématiques posées par le travail en équipe sur une relativement longue période. Les features que j\u0026rsquo;ai pu développer sont également très variées, ce qui me permet d\u0026rsquo;avoir une très bonne vision de l\u0026rsquo;ensemble du moteur. J\u0026rsquo;ai notamment développé :\nLa librairie de mathématiques (Vector2-3-4, Matrix4, Quaternion\u0026hellip;) + tests unitaires Système de callbacks et d\u0026rsquo;events custom La logique globale du moteur (main loop, gestion des scènes, gestion du temps) L\u0026rsquo;ECS (Entity Component System) Certains components de base (Transform) Le système de gestion de projets et d\u0026rsquo;assets Le wrapping + implémentation de la librairie de physique L\u0026rsquo;ensemble du système de réflection et de sérialisation Le système de HotReload L\u0026rsquo;inspecteur de l\u0026rsquo;éditeur (génération de widgets générique pour les classes utilisateurs + wrapping des components spécifiques à l\u0026rsquo;Engine) Le picking, les gizmos, le multiple-viewports et le controlleur de la scène Une grande partie du jeu (concept, énigmes) Ce projet est probablement le projet qui m\u0026rsquo;a le plus apporté mais aussi le plus plu depuis que j\u0026rsquo;ai commencé la programmation. J\u0026rsquo;ai pu découvrir de manière concrète en quoi consistait la programmation moteur, et j\u0026rsquo;ai le sentiment que mes compétences ont réellement évolué, que ce soit en programmation ou en gestion.\n","title":"Turbo Engine"},{"link":"/fr/posts/sslp/","text":"Détails Effectif : 2 programmeurs Délai : 1 mois (en parallèle avec d\u0026rsquo;autres projets) Technologies / Langages : Unity 2018, C#, Visual Studio 2017, Git, Trello Plateforme : Android Présentation Ce projet avait pour objectif de mettre en application un système de génération procédurale de terrain en 2D. Nous n\u0026rsquo;avions aucune contrainte particulière de production, si ce n\u0026rsquo;est d\u0026rsquo;implémenter et de faire apparaître un terrain 2D généré procéduralement. Slide Slide Little Penguin reprend donc le concept de base de Tiny Wings, mais les règles sont différentes : le but est de parcourir la plus longue distance possible en 30 secondes. Le meilleur score du joueur est enregistré et affiché sur l\u0026rsquo;écran titre.\nLes défis proposés par ce projet étaient multiples : on retrouve notamment la problématique des performances mobiles, et un challenge mathématique non négligeable. La physique est elle aussi complètement custom, pour éviter d\u0026rsquo;utiliser les colliders de Unity trop coûteux en performances pour l\u0026rsquo;effet recherché.\nContribution personnelle Je me suis personnellement occupé du développement des courbes mathématiques et de la physique. L\u0026rsquo;idée était de transformer des courbes connues pour les faire tenir dans des rectangles générés aléatoirement, avec une contrainte supplémentaire cependant : avoir des tangentes plates aux extremités (coefficient directeur nul) pour que le terrain soit continu. Sur l\u0026rsquo;image ci-dessus, on peut voir dans la vue éditeur (viewport supérieur) les rectangles générés aléatoirement. Les rectangles verts représentent des portions de courbes ascendantes, tandis que les rectangles rouges représentent des portions de courbes descendentes. Les courbes implémentées ont toutes demandé un travail préparatoire, à savoir la résolution des équations. Une fois les équations résolues, l\u0026rsquo;implémentation en code a été relativement simple. Au final, ont été implémentées les fonctions sinusoïdales, les fonctions polynomiales de degré 3, l’arc de cercle ou elliptique, ainsi que la fonction \u0026ldquo;Tangente Hyperbolique\u0026rdquo;. En ce qui concerne la physique, l\u0026rsquo;idée était d\u0026rsquo;avoir une sensation de glisse agréable donc les calculs réalisés ne sont pas du tout réalistes. Des calculs de pénétration sont réalisés avec les portions de terrain proches, et s\u0026rsquo;il y a pénétration on replace le pingouin sur la courbe en plus d\u0026rsquo;ajuster sa vélocité en fonction de son angle d\u0026rsquo;impact et de la tangente du terrain.\nCe projet a été ma première expérience sur mobile, et le rendu final est vraiment au rendez-vous, bien que le concept de base soit simple.\n","title":"Slide Slide Little Penguin"},{"link":"/fr/posts/stellar-pulse/","text":"Détails Effectif : 3 programmeurs, 4 game designers Délai : 1 mois Technologies / Langages : Unreal Engine 4, C++, Visual Studio 2017, Git, Trello, Slack Plateforme : PC (Oculus Rift) Présentation Stellar Pulse est un jeu de rythme et de shoot en VR dans lequel le joueur prend le contrôle de deux vaisseaux qu\u0026rsquo;il doit faire passer dans des anneaux en rythme avec la musique, en évitant les obstacles et en détruisant les ennemis.\nStellar Pulse a été récompensé de deux prix (Prix du Gameplay et Prix du Jury) parmi 4 prix distribués (les deux autres étaient le prix technique et le prix de l\u0026rsquo;originalité) lors d\u0026rsquo;une journée de présentation de tous les jeux VR développés au cours de cette session.\nContribution personnelle Tous les ennemis et leurs comportements Le système de tir du vaisseau (aide à la visée, beam particules) Système de pooling générique pour tous les objets d\u0026rsquo;un niveau (astéroïdes, vaisseaux, bullets, anneaux\u0026hellip;) Les boutons (menu et jeu) Le splash screen Le vaisseau HUD avec score et combos L\u0026rsquo;intégration des sons et particules ","title":"Stellar Pulse"},{"link":"/fr/posts/gladiator/","text":"Détails Effectif : 2 programmeurs Délai : 1 mois Technologies / Langages : Unreal Engine 4, C++, Visual Studio 2017, Git, Trello Plateforme : PC Présentation Le projet Gladiator était un projet qui avait pour premier objectif de nous faire découvrir UE4. L\u0026rsquo;idée était de créer un Battle Arena à la troisième personne avec les assets à notre disposition (meshs, animations, sons). Le jeu est jouable en solo (contre l\u0026rsquo;IA) mais aussi en multijoueur online (mode COOP et mode PvP).\nContribution personnelle Je me suis énormément investi sur ce projet, ce qui m\u0026rsquo;a permis d\u0026rsquo;arriver au bout de l\u0026rsquo;implémentation réseau de Gladiator dans le temps imparti. Une attention toute particulière a été portée à l\u0026rsquo;architecture qui a été recommencée de zéro pour faciliter la diversification des modes de jeu (dont le mode online). Je n\u0026rsquo;ai utilisé les blueprints que pour le développement de l\u0026rsquo;UI, tout le reste est développé en C++ pur. J\u0026rsquo;ai travaillé sur une grande majorité des features, dont voici une liste non exhaustive :\nSystème d\u0026rsquo;IA complet (BehaviorTree et IA Manager) UI complète (menus, lobby, barres de vie\u0026hellip;) Système de météo changeante (pluie puis beau temps, répliqué sur le réseau) Système de score Drop d\u0026rsquo;équipement ramassable Système de lock (les ennemis peuvent être verrouillés pour auto target) Outline de l\u0026rsquo;ennemi verrouillé et/ou des équipements ramassables Mode réseau PvP Mode réseau COOP ","title":"Gladiator"},{"link":"/fr/posts/driftcarz/","text":"Détails Effectif : 2 programmeurs Délai : 2 semaines Technologies / Langages : Unity 2018, C#, C++, Visual Studio 2017, Git, Trello Plateforme : PC Présentation L\u0026rsquo;objectif de ce projet était de passer un jeu de course simple développé sous Unity en multijoueur online. Pour ce faire, nous avons dans un premier temps développé une librairie réseau (C++) en utilisant Winsock2 que nous avons importée dans Unity. Nous avons ensuite revu un petit peu l\u0026rsquo;architecture du jeu de course initial, pour faciliter l\u0026rsquo;implémentation du réseau. Enfin, nous avons implémenté la couche réseau dans le jeu. Nous recherchions cependant un petit peu de challenge et nous sentions qu\u0026rsquo;il était possible de faire quelque chose de bien polish en poussant le vice un peu plus loin. Nous avons donc étendu le jeu avec un certain nombre de nouvelles features :\nUn Master Server nous permettant de gérer un système de Lobby avec un listing des rooms existantes. Le joueur a alors la possibilité de host une partie en créant une room, ou rejoindre une partie existante Lorsqu\u0026rsquo;on est dans une room et que la partie n\u0026rsquo;a pas commencé, le host peut modifier les paramètres de la course (nombre de tours, nombre de joueurs). Lorsque tous les joueurs ont indiqué qu\u0026rsquo;ils étaient prêts, la partie commence Un chat disponible quand on a rejoint une room Un système de leaderboard qui affiche le temps que chaque joueur a mis pour compléter la course avec un classement Contribution personnelle Dans ce projet je me suis occupé de toute la partie librairie réseau dans un premier temps, puis de son implémentation dans le jeu. J\u0026rsquo;ai ensuite développé le système de Master Server (C#) et de chat. Mon collègue s\u0026rsquo;est quant à lui occupé de la partie purement Unity, à savoir de l\u0026rsquo;UI (menu / lobby UI, Chat UI, Leaderboard UI), du bind UI / MasterServer / Chat, de la refactorisation du code de départ et de la modification des assets.\n","title":"DriftCarz"},{"link":"/fr/posts/light-transfer/","text":"Détails Effectif : 2 programmeurs, 4 game designers Délai : 1 mois Technologies / Langages : Unity 2017, C#, Visual Studio 2017, Git, Trello Plateforme : PC (Controlleur Xbox) Présentation Light Transfer est un jeu d\u0026rsquo;infiltration développé à l\u0026rsquo;occasion d\u0026rsquo;un projet collaboratif avec les Game Designers en 1ère année de Game Programming. On y incarne deux entités, Apalis et Berezet, leur objectif étant de s\u0026rsquo;entraider pour se frayer un chemin jusqu\u0026rsquo;à la sortie. Apalis craint la lumière et son compagnon devra lui faire de l\u0026rsquo;ombre pour l\u0026rsquo;aider à passer. À l\u0026rsquo;inverse, Berezet craint l\u0026rsquo;ombre donc Apalis devra éclairer son chemin pour le guider.\nContribution personnelle Sur ce projet j\u0026rsquo;ai travaillé sur :\nLes ennemis La caméra La main feature (Apalis meurt dans la lumière et Berezet dans l\u0026rsquo;ombre) Les ondes de son Plusieurs items (mirroirs, radios, clés, portes, lampes, collectibles\u0026hellip;) Checkpoints Camera trail (système de cinématique) Items UI Shaders (items UI, outline) Best scores Pools (ondes de son\u0026hellip;) ","title":"Light Transfer"}],"tags":[]}