{"categories":[],"pages":[],"posts":[{"link":"/posts/kodgen-refureku/","text":"Details Technologies / Languages: C++17, libclang, toml11\r, Visual Studio 2019, Git, Trello Platform : Windows / Linux Introduction At the beginning, Kodgen and Refureku were a single library, but I thought some of the code could be reused for other purposes, which is the reason why I decided to split the initial codebase into 2 different libraries.\nKodgen\ris a C++17 parsing/code generation library. It is used by Refureku to generate the metadata of each tagged entity in the source code. Entities are tagged using a macro, and it is possible to change this macro very easily thanks to a settings file, or by modifying the parser/generator main directly.\nRefureku\ris a C17 dynamic reflection library. It allows to access information about tagged C entities like classes or enums.\nMotivation I wrote this library for a few reasons. First of all, reflection is a programmation concept I like a lot. My past experience on the Turbo Engine\rgave me the motivation to dig further and improve our previous implementation. Reflection is currently not natively supported by the C++ language, and we won\u0026rsquo;t see anything before C++23 in the standard. On the other hand, C# reflection is extremely powerful and pleasant to use. For that reason, Refureku API is greatly inspired from C# reflection system.\nA few C++ reflection libraries already exist, but most of them have flaws I wanted to avoid in my implementation. For example, in some implementations we have to write all reflected information twice: once to declare the entity (let\u0026rsquo;s say a class with several fields and methods), and once again to tell the program to reflect that entity (which means we have to rewrite each field and method of a class/struct). It could look like this:\nCPP\rCollapse\rCopy\rclass ExampleClass { private: int i; }; REFLECT_CLASS(\u0026#34;ExampleClass\u0026#34;, (int) i)\rClick to expand and view more\rWriting things twice is 1. long and 2. error-prone when we modify entities (and god knows that we do!). The good point with that method however is that we can decide what is reflected and what\u0026rsquo;s not. It would be even better if all the codebase could be reflected automatically, but there would be a significant memory footprint (because of third party libraries / STL includes if there are any). That\u0026rsquo;s why it\u0026rsquo;s still good news to be able to choose. Another advantage is that we can attach properties (think of C# properties like System.Serializable, or Unity SerializeField for example) to the reflected entities. It can be very useful to develop a game engine for example.\nWith Refureku, we just have to tag the entity to reflect with a macro, and we can append attributes as macro parameters to add information on the entity. That way, we write the reflected entity only once, and it is straightforward to edit the code afterwards.\nCPP\rCollapse\rCopy\r#include \u0026#34;Generated/ExampleClass.rfk.h\u0026#34; class ReflectedClass(ExampleClassAttribute1) ExampleClass { private: ReflectedField(ExampleFieldAttribute1, ExampleFieldAttribute2) int i; ExampleClass_GENERATED };\rClick to expand and view more\r","title":"Kodgen \u0026 Refureku"},{"link":"/posts/lambos-tale/","text":"\rLambo's Tale by cfazilleau\rDetails Headcount: 4 programmers, 4 game designers, 3 artists Time period: 5 weeks Technologies / Languages: Unity 2019.3, C#, Visual Studio 2019, Perforce, Trello Platform: PC / Gamepad Introduction This project, realized with a team of 11 people mixing programmers, game designers and game artists, represents our third year final project. It is a bit special as it was a 100% remote project (due to Covid-19), and most of the team members had never met before.\nLambo\u0026rsquo;s Tale is a Metroidvania game in which we play as Lambo, a little lamb who\u0026rsquo;s trying to take revenge on the wolf gang which bullied his little sister.\nPersonal implication Procedural generation level system Enemies + AI Redaction of a part of the TDD (Technical Design Document) Camera Character A part of the player controller (jump snap, enemies snap) Interaction system (shop, doors, items) Semi-persistent inventory system Arenas logic Generic feedbacks system (particles, sounds, haptics, camera shakes) Pooling system LD bricks (doors, keys, destructibles, spikes, pickable items) Loading screen Damage feedback system FTUE (First Time User Experience - Tutorial) scripted parts Shop logic Assets integration (animations, sprites) ","title":"Lambo's Tale"},{"link":"/posts/poshon/","text":"Details Headcount: 2 programmers Time period: 2 weeks Technologies / Languages: Unity 2019.3, C#, Visual Studio 2019, Git, Trello Platform: Nintendo Switch Introduction This project was a R\u0026amp;D project on Nintendo Switch. Our objective was to explore the functionalities of this console by creating a local multiplayer party-game. Poshon (ポーション) is a local multiplayer party-game in which players have to reproduce potions as accurately as possible within a given amount of time. Potion attributes can be changed by interacting with the environment and completing mini-games.\nPersonal implication Creation of a UE4-like framework (Game Mode / Game State / Character / Controller) Setup the whole gameflow Camera / Controller / Character Interactable objects system Mini-game for each interactable object, taking advantage of the Nintendo Switch specific inputs (gyroscope, accelerometer, buttons) Multiplayer mode using the Unity new Input System Design of different levels Loading screen Scoring system ","title":"Poshon"},{"link":"/posts/turbo-engine/","text":"","title":"Turbo Engine"},{"link":"/posts/turbo-engine/","text":"Details Headcount: 4 programmers Time period: 5 months Technologies / Languages: Visual Studio 2017, Git, Trello, C++17, Python 3.7 Libraries: Qt, GLFW, PhysX, FMOD, nlohmann json, OpenGL, Freetype, stb_image, Glew, Autodesk FBX SDK, TinyObjLoader, SOL2, RuntimeCompiledCPlusPlus Introduction This second-year end project was composed of three sub-projects:\nDevelopment of a 3D game engine Development of an editor for this engine Development of a game using the engine The Turbo Engine Turbo Engine is a 3D video game engine which allows a fast and smooth development. It implements a wide range of useful features such as physics with a customable layer system (PhysX 3.4), sound management (FMOD), a material editor, or a full PBR (Physically Based Rendering) rendering pipeline with a bunch of post-process effects. The reflection system allows to serialize data in binary (custom) or text format (json using nhlomann json library). Thanks to the hotreload mecanism, the user can add and/or modify scripts and add them right away to the scene entities. The scripting system (C++) was thought to be easy to use: the user just has to use special keywords above its functions / variables to notify the engine that they have something special (for example, notify the engine to reflect a variable). A Python 3.7 based software will then parse user scripts and generate new metadata files for the Engine.\nThe Turbo Editor The Turbo Editor is based on the Qt library. It is made of a bunch of widgets which are undockable, allowing the user to organize his/her own layout as pleased. Here is a list of the different available widgets:\nThe file explorer to have a look on the project files The logger The Scene tree, to have an eye on the scene objects and how they are organized The inspector, which displays and allows the user to interact with entity components The Sound list, which displays all imported sounds and allows to listen them The Mixer, which allows to create and/or manage sounds channels The material editor, which allows to create and/or modify materials using all project textures and shaders The physics settings, which allow to manage physics layers and fixed time The game view The scene view, which can be opened up to 4 times simultaneously to edit or vizualize the scene from different point of views We can create scripts with customised templates and compile them in a simple clic. Scripts can then be edited and added to scene entities, and variables which were labelled with the \u0026ldquo;Reflected\u0026rdquo; attribute should be available in the editor.\nHere is an example of generated script with some variables:\nCPP\rCollapse\rCopy\r#pragma once #include \u0026lt;TEConfig.hpp\u0026gt; #include \u0026lt;Core/FundamentalTypes.hpp\u0026gt; #include \u0026lt;Core/ECS/Components/BehaviorComponent.hpp\u0026gt; #include \u0026lt;GameplayMinIncludes.hpp\u0026gt; // * This include should always be the last one. moving it will cause conflicts #include \u0026#34;Generated/TestScript.generatedhpp\u0026#34; class [[ReflectedClass(Component)]] TestScript : public turbo::core::ecs::BehaviorComponent { TURBO_CLASS_GENERATION() private: #pragma region Variables [[ReflectedAttr]] TEint16\tm_testInt = 16u; [[ReflectedAttr]] Vector\u0026lt;math::Vector3f\u0026gt;\tm_vector; [[ReflectedAttr]] RigidBody*\tm_rigidBody; //This attribute will not be shown in the editor thanks to the HiddenInEditor attribute [[ReflectedAttr, HiddenInEditor]] TEfloat\tm_hiddenAttribute; #pragma endregion protected: #pragma region Methods virtual void init()\tnoexcept override; virtual void update()\tnoexcept override; #pragma endregion }; REGISTER_TO_REFLECTION()\rClick to expand and view more\rAnd the corresponding .cpp, also generated without any user modification (except the RigidBody include):\nCPP\rCollapse\rCopy\r#include \u0026#34;TestScript.hpp\u0026#34; #include \u0026#34;Components/Physic/RigidBody.hpp\u0026#34; void TestScript::init() noexcept { Parent0::init(); } void TestScript::update() noexcept { Parent0::update(); }\rClick to expand and view more\rAs we can see here, we can call overriden functions in derived versions through the Parent0, Parent1, \u0026hellip; ParentN alias to extend behaviors.\nThe Turbo Game The game we had to create had to show as much as possible all the possibilities of the engine. We also had to respect some constraints, like the fact that the game had to be a FPS-Puzzle. We opted for a narrative adventure game. In the game, we play an archeolog who explores an old temple, following the inscructions given by her mate through a talkie walkie. I won\u0026rsquo;t say much more here to keep some surprises to the future players.\nPersonal implication During this project, I had the chance to work on all sub-projects. As the group leader, I had to face quite a lot of problems, like group cohesiveness or global tasks organization. I worked on a wide range of features which allows me to have a great global view of the engine:\nThe maths library (Vector2-3-4, Matrix4, Quaternions\u0026hellip;) + unit tests Custom callback and event system Global engine logic (main loop, scenes management, time management) The ECS (Entity Component System) Some basic components (Transform) Projects and assets management system Physic library wrapping and implementation The whole reflection and serialization system The Hotreload system Editor inspector (generic widgets generation for user scripts + engine specific components wrapping) Physics based picking, gizmos, multiple viewports handling and scene free controller A great part of the game (concept, riddles) This project is without any doubt the more pleasant project I have worked on since I started programmation. I had the chance to discover what exactly was engine programmation, and I feel like I truly improved my programmation and management knowledge.\n","title":"Turbo Engine"},{"link":"/posts/sslp/","text":"Details Headcount: 2 programmers Time period: 1 month (alongside other projects) Technologies / Languages: Unity 2018, C#, Visual Studio 2017, Git, Trello Platform: Android Introduction This project was about working on procedural generation of 2D terrain. Slide Slide Little Penguin looks like the game \u0026ldquo;Tiny Wings\u0026rdquo;, but the game\u0026rsquo;s goal is a bit different: the player has to make his/her penguin go as far as possible in 30 seconds. Best scores are saved and displayed on the title screen.\nMaking this game brought some challenges on the table. The first one was, of course, the mathematics challenge for the terrain procedural generation. Mobile performances were also to take into account (there is a custom physic system to avoid using Unity\u0026rsquo;s one, which is too heavy for what we were looking for).\nPersonal implication I mostly worked on the mathematics and physics part. The idea was to transform known curves to make sure they can fit in a rectangle with random dimensions, and assert extremum tangents were horizontal (i.e. curve slope is 0) so that the terrain can be continuous and smooth. If we look at the image above, we can see in the editor view (upper viewport) some randomly generated rectangles. Green rectangles represent ascending curves, while red rectangles represent descending curves. Each kind of curve required some work to resolve equations first, and then was implemented in the game (sinusoidal, polynomial of degree 3, ellptic arc, hyperbolic tangent). The custom physics system was about having a smooth slide feeling so calculations are not real physics at all.\nThis project was my first time working on a mobile project, it was cool and fun to make, and I think the game is quite good for the given time.\n","title":"Slide Slide Little Penguin"},{"link":"/posts/sslp/","text":"//TODO Contenu du post\n","title":"Slide Slide Little Penguin"},{"link":"/posts/stellar-pulse/","text":"Details Headcount: 3 programmers, 4 game designers Time period: 2 weeks Technologies / Languages: Unreal Engine 4, C++, Visual Studio 2017, Git, Trello, Slack Platform: PC (Oculus Rift) Introduction Stellar Pulse is a VR rythm shooting game in which the player controls two spaceships and makes them go through rings following the music. Be careful to asteroids and make sure to get rid of all the enemies!\nPersonal implication Enemies + AI Spaceship shoot system (auto-aim, beam particles) Generic pooling system (asteroids, enemies, bullets, rings\u0026hellip;) Buttons (menu + in-game) Splash screen Spaceship HUD (score + combos) Sounds \u0026amp; Particles integration ","title":"Stellar Pulse"}],"tags":[]}